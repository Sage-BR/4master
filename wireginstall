#!/bin/bash

###############################################
# WireGuard Easy - Script de Instalação
# By: 4master
###############################################

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log()    { echo -e "${GREEN}[+]${NC} $1"; }
warn()   { echo -e "${YELLOW}[!]${NC} $1"; }
error()  { echo -e "${RED}[✗]${NC} $1"; exit 1; }
header() { echo -e "\n${CYAN}========== $1 ==========${NC}\n"; }

# Verificar root
if [ "$EUID" -ne 0 ]; then
  error "Execute como root: sudo ./wireginstall"
fi

header "WireGuard Easy Installer"

# Coletar informações do usuário
read -p "IP público do servidor (ex: 202.78.170.67): " WG_HOST
[ -z "$WG_HOST" ] && error "IP público não pode ser vazio."

read -p "IPs permitidos no WireGuard (ex: 144.217.49.14/32,167.114.114.31/32): " WG_ALLOWED
[ -z "$WG_ALLOWED" ] && WG_ALLOWED="0.0.0.0/0"

read -s -p "Senha para o painel web wg-easy: " WG_PASSWORD
echo ""
[ -z "$WG_PASSWORD" ] && error "Senha não pode ser vazia."

read -p "Interface de rede (ex: ens3, eth0): " NET_IF
[ -z "$NET_IF" ] && NET_IF="ens3"

###############################################
# 1. INSTALAR DOCKER
###############################################
header "Instalando Docker"

if ! command -v docker &>/dev/null; then
  curl -sSL https://get.docker.com | sh
  log "Docker instalado com sucesso."
else
  warn "Docker já está instalado, pulando..."
fi

###############################################
# 2. GERAR HASH DA SENHA
###############################################
header "Gerando hash da senha"

if ! command -v htpasswd &>/dev/null; then
  apt-get install -y apache2-utils -qq
fi

RAW_HASH=$(htpasswd -bnBC 12 "" "$WG_PASSWORD" | tr -d ':\n' | sed 's/\$2y/\$2a/')
# Escapar $ para docker-compose
PASSWORD_HASH=$(echo "$RAW_HASH" | sed 's/\$/\$\$/g')

log "Hash gerado."

###############################################
# 3. CRIAR docker-compose.yml
###############################################
header "Criando configuração do wg-easy"

mkdir -p /opt/wg-easy
cd /opt/wg-easy

cat > docker-compose.yml <<EOF
services:
  wg-easy:
    image: ghcr.io/wg-easy/wg-easy
    container_name: wg-easy
    environment:
      - LANG=pt
      - WG_HOST=${WG_HOST}
      - PASSWORD_HASH=${PASSWORD_HASH}
      - WG_ALLOWED_IPS=${WG_ALLOWED}
      - WG_DEFAULT_DNS=1.1.1.1
      - WG_PERSISTENT_KEEPALIVE=25
    volumes:
      - ./data:/etc/wireguard
    ports:
      - "443:51820/udp"
      - "51821:51821/tcp"
    restart: unless-stopped
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    sysctls:
      - net.ipv4.ip_forward=1
      - net.ipv4.conf.all.src_valid_mark=1
      - net.ipv4.conf.all.rp_filter=0
    privileged: true
EOF

log "docker-compose.yml criado em /opt/wg-easy/"

###############################################
# 4. CONFIGURAR QoS (CAKE + IFB + DSCP)
###############################################
header "Configurando QoS (CAKE + ingress IFB + DSCP)"

# Garantir backend iptables-nft antes de qualquer regra
update-alternatives --set iptables /usr/sbin/iptables-nft 2>/dev/null || true
update-alternatives --set ip6tables /usr/sbin/ip6tables-nft 2>/dev/null || true

cat > /etc/network/if-up.d/qos-games <<QOSEOF
#!/bin/bash
IF=${NET_IF}
WG_PORT=443

# ─────────────────────────────────────────
# LIMPEZA
# ─────────────────────────────────────────
tc qdisc del dev \$IF root 2>/dev/null || true
tc qdisc del dev \$IF ingress 2>/dev/null || true
ip link del ifb0 2>/dev/null || true

# ─────────────────────────────────────────
# INGRESS (via IFB)
# ─────────────────────────────────────────
modprobe ifb numifbs=1
ip link add ifb0 type ifb
ip link set ifb0 up

tc qdisc add dev \$IF ingress
tc filter add dev \$IF parent ffff: protocol ip u32 match u32 0 0 \
    action mirred egress redirect dev ifb0

# ─────────────────────────────────────────
# EGRESS — tráfego saindo do servidor
# ─────────────────────────────────────────
if tc qdisc add dev \$IF root cake bandwidth 1gbit diffserv4 2>/dev/null; then
    echo "CAKE egress ativado"
    CAKE_OK=1
else
    echo "CAKE não disponível, usando HTB+fq_codel"
    CAKE_OK=0
    tc qdisc add dev \$IF root handle 1: htb default 30
    tc class add dev \$IF parent 1: classid 1:1 htb rate 1gbit
    tc class add dev \$IF parent 1:1 classid 1:10 htb rate 950mbit ceil 1gbit prio 1 burst 1k
    tc class add dev \$IF parent 1:1 classid 1:30 htb rate 50mbit  ceil 1gbit prio 3 burst 15k
    tc qdisc add dev \$IF parent 1:10 handle 10: fq_codel target 500us interval 5ms quantum 300
    tc qdisc add dev \$IF parent 1:30 handle 30: fq_codel target 5ms interval 50ms
    tc filter add dev \$IF parent 1: protocol ip prio 1 u32 \
        match ip protocol 17 0xff \
        match ip sport \$WG_PORT 0xffff \
        flowid 1:10
    tc filter add dev \$IF parent 1: protocol ip prio 2 u32 \
        match ip protocol 17 0xff \
        match ip dport \$WG_PORT 0xffff \
        flowid 1:10
    tc filter add dev \$IF parent 1: protocol ip prio 10 u32 \
        match u32 0 0 \
        flowid 1:30
fi

# ─────────────────────────────────────────
# INGRESS — tráfego entrando no servidor
# ─────────────────────────────────────────
if [ "\$CAKE_OK" = "1" ] && tc qdisc add dev ifb0 root cake bandwidth 1gbit diffserv4 ingress 2>/dev/null; then
    echo "CAKE ingress ativado"
else
    echo "Usando HTB+fq_codel no ingress"
    tc qdisc add dev ifb0 root handle 1: htb default 30
    tc class add dev ifb0 parent 1: classid 1:1 htb rate 1gbit
    tc class add dev ifb0 parent 1:1 classid 1:10 htb rate 950mbit ceil 1gbit prio 1 burst 1k
    tc class add dev ifb0 parent 1:1 classid 1:30 htb rate 50mbit  ceil 1gbit prio 3 burst 15k
    tc qdisc add dev ifb0 parent 1:10 handle 10: fq_codel target 500us interval 5ms quantum 300
    tc qdisc add dev ifb0 parent 1:30 handle 30: fq_codel target 5ms interval 50ms
    tc filter add dev ifb0 parent 1: protocol ip prio 1 u32 \
        match ip protocol 17 0xff \
        match ip dport \$WG_PORT 0xffff \
        flowid 1:10
    tc filter add dev ifb0 parent 1: protocol ip prio 2 u32 \
        match ip protocol 17 0xff \
        match ip sport \$WG_PORT 0xffff \
        flowid 1:10
    tc filter add dev ifb0 parent 1: protocol ip prio 10 u32 \
        match u32 0 0 \
        flowid 1:30
fi

# ─────────────────────────────────────────
# DSCP marking — prioriza WireGuard no CAKE
# ─────────────────────────────────────────
iptables -t mangle -F
iptables -t mangle -A PREROUTING  -p udp --dport \$WG_PORT -j DSCP --set-dscp-class EF
iptables -t mangle -A PREROUTING  -p udp --sport \$WG_PORT -j DSCP --set-dscp-class EF
iptables -t mangle -A POSTROUTING -p udp --dport \$WG_PORT -j DSCP --set-dscp-class EF
iptables -t mangle -A POSTROUTING -p udp --sport \$WG_PORT -j DSCP --set-dscp-class EF

# ─────────────────────────────────────────
# VERIFICAÇÃO
# ─────────────────────────────────────────
echo ""
echo "=== egress (\$IF) ==="
tc qdisc show dev \$IF

echo ""
echo "=== ingress (ifb0) ==="
tc qdisc show dev ifb0

echo ""
echo "=== DSCP mangle ==="
iptables -t mangle -L -n --line-numbers
QOSEOF

chmod +x /etc/network/if-up.d/qos-games
bash /etc/network/if-up.d/qos-games || warn "QoS aplicado (ignore erros de del se for primeira vez)"
log "QoS configurado."

###############################################
# 5. SYSCTL (otimizações de rede)
###############################################
header "Aplicando otimizações de kernel (sysctl)"

cat > /etc/sysctl.d/99-wireguard.conf <<SYSEOF
############################
# CORE NETWORK
############################
net.core.default_qdisc = cake
net.ipv4.tcp_congestion_control = bbr
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.ipv4.tcp_rmem = 4096 131072 67108864
net.ipv4.tcp_wmem = 4096 131072 67108864
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
net.core.netdev_max_backlog = 5000

############################
# FORWARDING (WireGuard)
############################
net.ipv4.ip_forward = 1

############################
# TCP STABILITY
############################
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_moderate_rcvbuf = 1

############################
# BASIC SECURITY (SAFE)
############################
net.ipv4.tcp_syncookies = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0

############################
# FILE LIMIT
############################
fs.file-max = 65536

############################
# LATÊNCIA
############################
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_keepalive_time = 60
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl = 15
net.ipv4.tcp_fin_timeout = 15
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_tw_reuse = 1

############################
# WIREGUARD (UDP)
############################
net.ipv4.udp_early_demux = 0
SYSEOF

sysctl -p /etc/sysctl.d/99-wireguard.conf
log "Sysctl aplicado."

###############################################
# 6. SUBIR wg-easy PRIMEIRO (antes do iptables)
###############################################
header "Iniciando wg-easy"

cd /opt/wg-easy
docker compose up -d
log "wg-easy iniciado! Aguardando Docker estabilizar..."
sleep 5

###############################################
# 7. IPTABLES (após Docker subir)
###############################################
header "Configurando iptables"

apply_iptables() {
  local IF=$1

  iptables -F INPUT
  iptables -F OUTPUT
  iptables -F FORWARD
  iptables -t nat -F POSTROUTING
  iptables -t nat -F OUTPUT

  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT ACCEPT

  ########################################
  # NAT
  ########################################
  iptables -t nat -A POSTROUTING -o "$IF" -j MASQUERADE

  ########################################
  # INPUT
  ########################################
  iptables -A INPUT -i lo -j ACCEPT
  iptables -A INPUT -i wg0 -j ACCEPT
  iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

  # Anti-spoofing
  iptables -A INPUT -s 127.0.0.0/8 ! -i lo -j DROP
  iptables -A INPUT -s 224.0.0.0/4 -j DROP
  iptables -A INPUT -s 169.254.0.0/16 -j DROP

  # TCP flags maliciosas
  iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP
  iptables -A INPUT -p tcp --tcp-flags ALL ALL -j DROP
  iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
  iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP

  # SSH com proteção brute-force
  iptables -A INPUT -p tcp --dport 22 -m recent --name SSH --rcheck --seconds 120 --hitcount 6 -j DROP
  iptables -A INPUT -p tcp --dport 22 -m recent --name SSH --set
  iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT

  # WireGuard
  iptables -A INPUT -p udp --dport 51820 -j ACCEPT

  # Web UI wg-easy
  iptables -A INPUT -p tcp --dport 51821 -j ACCEPT

  # ICMP com rate limit
  iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s --limit-burst 10 -j ACCEPT
  iptables -A INPUT -p icmp -j ACCEPT

  iptables -A INPUT -j DROP

  ########################################
  # FORWARD
  ########################################
  iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  iptables -A FORWARD -i wg0 -o "$IF" -j ACCEPT
  iptables -A FORWARD -i br+ -o "$IF" -j ACCEPT
  iptables -A FORWARD -i "$IF" -o br+ -j ACCEPT
  iptables -A FORWARD -j DROP
}

apply_iptables "${NET_IF}"
log "iptables aplicado (chains Docker preservadas)."

###############################################
# 8. SYSTEMD — persistência do QoS no boot
###############################################
header "Configurando persistência do QoS (systemd)"

cat > /etc/systemd/system/tc-qos.service <<SVCEOF
[Unit]
Description=TC QoS WireGuard
After=network.target docker.service
Wants=docker.service

[Service]
Type=oneshot
ExecStart=/etc/network/if-up.d/qos-games
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SVCEOF

systemctl daemon-reload
systemctl enable tc-qos
log "Serviço tc-qos habilitado no boot."

# rc.local como fallback
cat > /etc/rc.local <<IPTEOF
#!/bin/sh -e

# Aguardar Docker subir e criar suas chains antes de aplicar o firewall
sleep 10

apply_iptables() {
  local IF=\$1
  iptables -F INPUT
  iptables -F OUTPUT
  iptables -F FORWARD
  iptables -t nat -F POSTROUTING
  iptables -t nat -F OUTPUT

  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT ACCEPT

  iptables -t nat -A POSTROUTING -o "\$IF" -j MASQUERADE

  iptables -A INPUT -i lo -j ACCEPT
  iptables -A INPUT -i wg0 -j ACCEPT
  iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
  iptables -A INPUT -s 127.0.0.0/8 ! -i lo -j DROP
  iptables -A INPUT -s 224.0.0.0/4 -j DROP
  iptables -A INPUT -s 169.254.0.0/16 -j DROP
  iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP
  iptables -A INPUT -p tcp --tcp-flags ALL ALL -j DROP
  iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
  iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  iptables -A INPUT -p tcp --dport 22 -m recent --name SSH --rcheck --seconds 120 --hitcount 6 -j DROP
  iptables -A INPUT -p tcp --dport 22 -m recent --name SSH --set
  iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT
  iptables -A INPUT -p udp --dport 51820 -j ACCEPT
  iptables -A INPUT -p tcp --dport 51821 -j ACCEPT
  iptables -A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/s --limit-burst 10 -j ACCEPT
  iptables -A INPUT -p icmp -j ACCEPT
  iptables -A INPUT -j DROP

  iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  iptables -A FORWARD -i wg0 -o "\$IF" -j ACCEPT
  iptables -A FORWARD -i br+ -o "\$IF" -j ACCEPT
  iptables -A FORWARD -i "\$IF" -o br+ -j ACCEPT
  iptables -A FORWARD -j DROP
}

apply_iptables ${NET_IF}

exit 0
IPTEOF

chmod +x /etc/rc.local
log "rc.local salvo como fallback."

###############################################
# FINALIZADO
###############################################
header "Instalação Concluída!"

echo -e "${GREEN}✔ Painel web disponível em:${NC} http://${WG_HOST}:51821"
echo -e "${GREEN}✔ Porta WireGuard:${NC} UDP 51820"
echo -e "${GREEN}✔ QoS:${NC} CAKE egress + ingress (IFB) com DSCP EF"
echo -e "${GREEN}✔ Backend iptables:${NC} nft"
echo -e "${YELLOW}Dica:${NC} Para ver logs: cd /opt/wg-easy && docker compose logs -f"
